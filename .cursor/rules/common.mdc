---
alwaysApply: true
---

## Язык
- Всегда отвечать на русском.

## Общая логика приложения
- Приложение доступно без логина (гостевой режим).
- Экран логина показывается только при действиях, требующих сохранения пользовательских данных (юзер‑специфичных сущностей). После успешного логина действие продолжается.
- Основа навигации — TabBar/BottomNavigation, без отдельного navigation bar (пока). Локальная навигация внутри вкладок допускается при росте сложности.

## Архитектурные правила
- Подход «feature‑first»: код группируется по модулям/фичам. Инфраструктура — в `Core`.
- Слои внутри фичи: `Models` (модели/контракты), `Presentation` (виджеты/страницы/состояние).
- DAO/кеши, специфичные для фичи, размещать в `Core/Database`. Общие сервисы — в `Core`.
- MVVM строится относительно экрана, `View/Screen` - только отображение, `Model/State` - формируется внутри `ViewModel`, который содержит бизнеслогику конкретного экрана
- Viper получается из модуля вьюшки и единого источника правды - провайдер, репозитоирий и бд, которые уже хранятся в `Core` или в корне фичи

## MVVM архитектура

### View (Screen/Widget)
- **ЗАПРЕЩЕНО:** View НЕ МОЖЕТ напрямую обращаться к глобальным провайдерам (UserNotifier, и т.д.)
- **ЗАПРЕЩЕНО:** View НЕ МОЖЕТ использовать `ref.listen`, `ref.watch`, `ref.read` на провайдеры кроме своего ViewModel
- **РАЗРЕШЕНО:** View использует ТОЛЬКО свой ViewModel провайдер через `ref.watch(myViewModelProvider)` и `ref.read(myViewModelProvider.notifier)`
- **РАЗРЕШЕНО:** View подписывается на callbacks ViewModel в `initState` через `addPostFrameCallback`

### ViewModel
- **РАЗРЕШЕНО:** ViewModel может слушать любые глобальные провайдеры через `ref.listen`, `ref.watch`, `ref.read`
- **ОБЯЗАТЕЛЬНО:** ViewModel предоставляет nullable callbacks для событий (`onError`, `onSuccess`, и т.д.)
- **ОБЯЗАТЕЛЬНО:** ViewModel содержит всю бизнес-логику экрана

**Правило:** View знает ТОЛЬКО о своей ViewModel. Всё остальное - через ViewModel.

## Навигация
- Корень — экран с TabBar/BottomNavigation.
- Экран логина открывается поверх (modal/fullscreen), не разрушая состояние интерфейса.

## Состояние
- Используется `Riverpod`.
- `UserNotifier` — источник правды по пользователю (`guest/loading/loggedIn`).

## Бэк API
- Используется `Dio`.

## Замечания для ассистента
- **Соблюдать принципы ООП**
- **Запрещено усложнять без причины**: Видишь typedef, когда можно передать класс напрямую? Видишь callback-обёртку, когда можно передать метод? Видишь builder, когда достаточно конструктора? СТОП. Упрости.
- Не перемещать инфраструктуру из `Core` без явной причины.
- Соблюдать текущий стиль кода и форматирование.
- Файлы называются через СamelСase, точно так, как назван класс внутри файла.
- Один файл - один класс.
- В конце файла всегда оставляй одну пустую строку
- Писать читаемый код

## State vs Events во ViewModel

### Запрещено
- Хранить события (ошибки, успехи операций) в State как флаги или строки
- Использовать флаги типа `isAuthenticated`, `isSuccess`, `error` в State для навигации или показа диалогов
- Слушать изменения State через `ref.listen` для триггера разовых действий
- Использовать счётчики событий в State (`errorCount`, `successCount`)

**Правило:** Видишь флаг в State для событий — это red flag. Что-то не так с архитектурой.

### Правильно
- **State содержит только данные**: поля форм, списки, текущие значения
- **События обрабатываются через callbacks**: `onError`, `onSuccess`, `onComplete`
- **ViewModel** предоставляет nullable callbacks для событий
- **View** подписывается на callbacks в `initState` через `addPostFrameCallback`

### Что считается данными, а что событиями
- **Данные (State)**: текст в поле, выбранный элемент, загружается ли что-то (`isLoading`), список элементов
- **События (Callbacks)**: ошибка произошла, действие завершено успешно, нужно показать диалог, нужна навигация

### Пример правильной архитектуры

// State - ТОЛЬКО данные
class MyState {
  final String email;
  final String password;
  final bool isLoading; // это состояние UI, не событие - OK

  // ❌ НЕТ: final String? error;
  // ❌ НЕТ: final bool isAuthenticated;
  // ❌ НЕТ: final int errorCount;
}

## Форматирование кода

**ЗАПРЕЩЕНО переформатировать существующий код без изменения смысла.**

**КРИТИЧЕСКИ ВАЖНО для search_replace:**
- При замене включай в блок **ТОЛЬКО** строки которые РЕАЛЬНО изменяются
- НЕ включай соседние строки "для контекста" - инструмент сам найдёт нужное место
- Если меняешь 1 строку - в блоке замены должна быть только 1 строка
- Если добавляешь код - включай только место вставки + новый код

### Что это значит:
- Если строка работает и ты её не меняешь по смыслу — НЕ ТРОГАЙ её форматирование
- НЕ добавляй trailing commas (запятые в конце параметров)
- НЕ переносить строки на несколько, если они были в одной
- НЕ менять отступы, если код рабочий
- НЕ "улучшать читаемость" без запроса

### Когда МОЖНО переформатировать:
- Ты **реально меняешь** содержимое строки (добавляешь параметр, меняешь логику)
- Пользователь **явно просит** отформатировать код
- Новый код, который ты **пишешь с нуля**
