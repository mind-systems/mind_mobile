# Поведение BreathSessionStateMachine и BreathViewModel

## Стейт-машина и её владелец

Логика дыхательной сессии разделена между двумя объектами. BreathSessionStateMachine — это изолированная стейт-машина, которая знает всё о дыхательных фазах, счётчиках и переходах, но ничего не знает о Riverpod или Flutter. BreathViewModel — это тонкий Riverpod StateNotifier, который владеет экземпляром стейт-машины, загружает данные сессии и транслирует изменения наружу в формате, понятном UI.

## Старт сессии

При вызове initState ViewModel асинхронно обращается к IBreathSessionService за данными сессии. Пока запрос выполняется, состояние имеет loadState равный loading. После получения DTO вызывается _setupEngine, который создаёт новый экземпляр BreathSessionStateMachine и сразу же транслирует его начальное состояние наружу с loadState равным ready.

Стейт-машина при создании сама определяет начальную фазу. Если первое упражнение является чистым отдыхом без шагов дыхания, состояние устанавливается в pause с фазой rest. Если упражнение содержит шаги дыхания, начальная фаза вычисляется из первого шага. В обоих случаях сессия всегда стартует в статусе pause — фактическое движение начинается только после вызова resume со стороны UI.

## Главный цикл обработки тиков

Каждое событие от TickService попадает напрямую в стейт-машину — ViewModel в обработке тиков не участвует. Стейт-машина обновляет своё внутреннее состояние и выбрасывает новый BreathSessionStateMachineState в stateStream. ViewModel подписан на этот стрим через _stateMachineSubscription и в обработчике _onEngineState пересчитывает отображаемое состояние таймлайна, после чего обновляет Riverpod state.

Если сессия находится на паузе или завершена, стейт-машина игнорирует входящие тики самостоятельно. ViewModel в этой логике не участвует.

## Дыхательная фаза

Во время дыхания каждый тик увеличивает внутренний счётчик _cycleTick на единицу. Этот счётчик отражает позицию внутри текущего дыхательного цикла. Длительность цикла фиксирована и равна сумме длительностей всех шагов упражнения.

Сначала проверяется, завершился ли цикл. Если да, счётчик сбрасывается, а _repeatCounter увеличивается. Далее проверяется, исчерпаны ли все повторы упражнения. Если да — вызывается _advanceExercise. Если повторы ещё остаются и у упражнения есть restDuration, запускается _startRest, иначе — _startNewCycle.

Если цикл продолжается, метод _getCurrentStepData определяет по текущему _cycleTick, в каком шаге находится система, и возвращает тип фазы и количество тиков, оставшихся до конца текущего шага. Эти данные формируют новое состояние.

## Фаза отдыха

Во время отдыха каждый тик также увеличивает _cycleTick. Когда он достигает restDuration, отдых считается завершённым. Если упражнение не содержит шагов дыхания — это отдельное упражнение-отдых, вызывается _advanceExercise. Если шаги есть — отдых был промежуточным между циклами, запускается _startNewCycle.

## Завершение упражнения и переходы

Метод _advanceExercise увеличивает _exerciseIndex и сбрасывает _cycleTick и _repeatCounter. Затем в resetStream отправляется событие exerciseChange. Если индекс выходит за пределы списка упражнений, вызывается complete, который фиксирует статус complete, отменяет подписку на TickService и закрывает resetStream.

Метод _startRest сбрасывает _cycleTick, отправляет событие rest в resetStream и устанавливает статус rest с фазой rest и полным restDuration в качестве remainingTicks.

Метод _startNewCycle отправляет событие newCycle в resetStream, определяет параметры первого шага нового цикла и устанавливает статус breath.

Отдых, заданный внутри упражнения, используется только между циклами и не применяется после последнего повтора. Отдых между упражнениями возможен только в том случае, если он оформлен как отдельное упражнение-отдых.

## Определение текущего шага

Метод _getCurrentStepData принимает номер тика внутри цикла и проходит по списку шагов упражнения, накапливая их длительности. Когда тик попадает в диапазон шага, возвращаются его фаза, индекс и количество тиков до конца этого шага. Если тик выходит за пределы всех шагов, возвращаются параметры последнего шага как fallback.

## Proxy-паттерн resetStream

BreathSessionStateMachine владеет собственным resetStream. При рестарте стейт-машина уничтожается и создаётся новая — её resetStream закрывается, и появляется свежий. Чтобы внешние подписчики не теряли подписку при каждом рестарте, ViewModel держит стабильный внутренний _resetController, который живёт весь lifecycle ViewModel. Подписка _resetProxySubscription прослушивает resetStream текущей стейт-машины и перенаправляет события в этот контроллер. При рестарте _setupEngine отменяет старую прокси-подписку и создаёт новую для нового экземпляра. Наружу ViewModel экспонирует viewModel.resetStream — стабильный стрим, который никогда не меняется.

## Facade-методы

ViewModel предоставляет набор методов, которые делегируют вызовы напрямую в стейт-машину: currentExercise, getCurrentPhaseInfo, getCurrentPhaseMeta, getNextPhaseInfo, getNextExerciseWithShape. Если стейт-машина ещё не создана, методы возвращают безопасные значения по умолчанию.

## Управление сессией

Методы pause и resume делегируют вызовы в стейт-машину. Метод complete тоже делегируется. Метод restart пересоздаёт стейт-машину через _setupEngine, используя кэшированный DTO, загруженный при первом вызове initState.
