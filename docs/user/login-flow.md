Логин в приложении возможен двумя способами: через Google Sign-In и через passwordless email-ссылку. Оба пути проходят через единую точку доменного состояния — UserNotifier — и завершаются одинаково: эмитом AuthenticatedState в основной поток состояния пользователя.

Google Sign-In инициируется прямо с экрана онбординга. Пользователь нажимает кнопку, LoginViewModel вызывает сервис, тот делегирует в UserNotifier, который устанавливает флаг authInProgress и запускает цепочку: нативный Google Sign-In, Firebase signInWithCredential, запрос к API. Пока операция выполняется, оба экрана — OnboardingScreen и LoginScreen — показывают оверлей через isLoginInProgress, который живёт в LoginState и синхронизируется с UserNotifier.authInProgressStream напрямую в конструкторе LoginViewModel. Никакого ручного управления isLoading для этого пути не нужно — домен сам знает, когда аутентификация начинается и заканчивается.

Email-ссылка работает иначе: пользователь вводит адрес на LoginScreen, нажимает кнопку, и LoginViewModel управляет isLoading вручную, пока выполняется sendPasswordlessSignInLink. Это не аутентификация — это просто отправка запроса, поэтому isLoginInProgress здесь не участвует. Сам логин происходит позже, когда пользователь переходит по ссылке из письма. Диплинк прилетает в DeeplinkRouter, передаётся в FirebaseDeeplinkHandler, который вызывает UserNotifier.completePasswordlessSignIn. С этого момента флаг authInProgress поднимается и поведение становится идентичным Google-пути: оверлей на любом активном экране блокирует UI, до завершения операции.

После успешной аутентификации UserNotifier эмитит AuthenticatedState. LoginViewModel подписан на этот поток и при получении вызывает onAuthenticatedEvent — колбэк, который каждый экран устанавливает в initState. OnboardingScreen и LoginScreen оба реагируют на него навигацией по returnPath. Этот путь обрабатывает в том числе диплинк-логин: пока пользователь находится на любом из экранов входа и переходит по ссылке из письма, экран заблокируется оверлеем и после успеха автоматически перейдёт туда, куда нужно.

Если аутентификация по диплинку завершается ошибкой, UserNotifier публикует сообщение об ошибке в authErrorStream до того, как пробросить исключение дальше. DeeplinkRouter поглощает исключение (чтобы не крашить стрим), а GlobalListeners, подписанный на authErrorStream, показывает снэкбар. Таким образом пользователь получает обратную связь даже в сценарии, где нет активного UI-обработчика ошибки — экран логина может быть не открыт вовсе.

Всё, что касается навигации после логина, живёт в returnPath — строке, которая передаётся при открытии OnboardingScreen или LoginScreen через GoRouter и хранится в LoginState. Роутер не содержит охранников авторизации: экраны входа всегда доступны, а редирект после логина — ответственность экрана, а не роутера.
