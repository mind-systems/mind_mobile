Аутентификация в приложении построена на принципе невидимости токена для основного кода. JWT существует как артефакт инфраструктуры, который течёт через систему автоматически, не требуя явного участия со стороны бизнес-логики или UI. Когда пользователь входит в систему, токен сохраняется в защищённом хранилище и с этого момента становится частью каждого запроса, но никто из вышестоящих слоёв не знает о его существовании и не управляет им напрямую.

AuthInterceptor выступает прозрачным слоем между приложением и сетью. Он перехватывает каждый исходящий запрос, читает токен из хранилища и молча добавляет его в заголовок, если токен присутствует. Запросы к эндпоинту аутентификации исключены из этой логики, поскольку там используется другой механизм идентификации — Firebase токен в теле запроса. Для всех остальных запросов токен добавляется автоматически, делая авторизацию невидимой для кода, который формирует запросы. Сервисы и репозитории ничего не знают о JWT и просто вызывают методы API, а интерсептор обеспечивает корректную авторизацию на уровне транспорта.

Когда токен перестаёт быть валидным, сервер возвращает ответ с кодом 401. Этот момент становится точкой распространения события через систему. AuthInterceptor ловит ошибку в методе обработки ответов, но не принимает решений о том, что делать с состоянием пользователя. Вместо этого он напрямую вызывает метод triggerLogout инжектированного LogoutNotifier — лёгкого event bus, существующего исключительно для передачи сигнала о невалидности сессии.

LogoutNotifier не содержит логики и не управляет данными. Его единственная задача — распространить событие на всех подписчиков через метод triggerLogout. Этот подход изолирует интерсептор от знания о UserNotifier и позволяет любым частям приложения реагировать на истечение сессии независимо. UserNotifier подписывается на LogoutNotifier при инициализации и при получении сигнала вызывает собственный метод clearSession, который выполняет локальную очистку без запроса на сервер, поскольку сервер уже считает токен невалидным. Метод clearSession удаляет токен из хранилища, выходит из Firebase и Google аккаунтов, очищает данные пользователя из базы и переводит состояние приложения в гостевой режим.

После того как UserNotifier меняет состояние на GuestState, это изменение распространяется на все экраны и компоненты, подписанные на состояние пользователя. Каждый экран принимает собственное решение о реакции: список сессий сбрасывает контент на гостевой, профиль может закрыться, формы очищаются. Это происходит без централизованного управления навигацией, поскольку приложение изначально построено как гостеприимное — большинство экранов доступны без авторизации, просто с ограниченным функционалом.

Важно, что ошибка 401 не поглощается интерсептором. После вызова triggerLogout она пробрасывается дальше через цепочку обработки и доходит до кода, который инициировал запрос. Это позволяет UI-слою показать локальное уведомление об ошибке, если это необходимо, при этом глобальная логика clearSession уже отработала через LogoutNotifier. Таким образом система поддерживает два независимых канала реакции: глобальное изменение состояния через нотифаер и локальную обработку ошибки в точке вызова.

Токен извлекается из заголовка ответа сервера при первичной аутентификации. Сервер возвращает JWT в заголовке Authorization с префиксом Bearer, а в теле ответа приходит объект пользователя. ApiService считывает заголовок, удаляет префикс и сохраняет чистый токен в защищённом хранилище. Существуют два сценария очистки токена: когда пользователь явно нажимает кнопку выхода, вызывается метод logout, который отправляет запрос на сервер и затем делегирует локальную очистку методу clearSession. Когда же сервер возвращает 401, вызывается напрямую clearSession, минуя запрос на сервер, поскольку сервер уже инвалидировал сессию. В обоих случаях токен удаляется из хранилища, гарантируя, что последующие запросы уйдут без авторизации и сервер вернёт гостевой контент.

Вся архитектура построена на принципе изоляции ответственности. AuthInterceptor знает о токенах и HTTP-заголовках, но ничего не знает о состоянии пользователя. LogoutNotifier знает только о событии, но не знает ни о токенах, ни о UI. UserNotifier управляет состоянием пользователя, но не знает о деталях работы интерсептора. Экраны реагируют на состояние, но не знают о причинах его изменения. Эта изоляция делает систему предсказуемой и расширяемой — добавление глобального уведомления о истечении сессии потребует лишь ещё одного подписчика на LogoutNotifier, без изменения существующего кода.
