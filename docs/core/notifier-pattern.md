Notifier<G> в нашей архитектуре — это живая точка входа в данные, через которую проходит всё взаимодействие приложения с состоянием и хранилищем. Он существует не как «хранилище логики», а как фасад, который соединяет мир UI и сервисов с миром репозиториев, обеспечивая единый, контролируемый поток изменений.

Любое чтение или запись данных происходит через нотифаер. UI никогда не обращается к репозиторию напрямую и не знает о его существовании. Сервисы также не работают с репозиторием напрямую — они взаимодействуют с нотифаером как с контрактом на сохранение, обновление или удаление данных. За счёт этого вся точка мутации сосредоточена в одном месте, и состояние всегда остаётся согласованным с источником данных.

Нотифаер одновременно решает две задачи. С одной стороны, он управляет состоянием: хранит актуальный срез данных, публикует изменения и гарантирует, что UI всегда подписан на корректное состояние. С другой стороны, он оркестрирует операции записи: принимает намерение изменить данные, преобразует его в доменную операцию и делегирует сохранение репозиторию. Репозиторий при этом остаётся «немым» — он ничего не знает о состоянии, реактивности или UI, и просто выполняет операции чтения и записи.

Важно, что нотифаер не является местом для сложной бизнес-логики. Он не принимает доменных решений и не содержит сценариев высокого уровня. Его роль — координация: определить момент записи, синхронизировать состояние до и после операции и уведомить подписчиков об изменениях. Если появляется логика, требующая осмысления предметной области, она выносится в сервисы или доменные функции, а нотифаер лишь вызывает их и отражает результат в состоянии.

Такой подход обусловлен средой Flutter. В условиях, где доступ к зависимостям осуществляется через `ref` и жизненный цикл тесно связан с UI, нотифаер становится естественной и безопасной точкой интеграции. Он живёт ровно столько, сколько нужно экрану или флоу, инкапсулирует инфраструктурные зависимости и не протекает наружу деталями реализации. В результате система остаётся простой: один вход, один поток изменений и предсказуемое поведение состояния во всём приложении.
