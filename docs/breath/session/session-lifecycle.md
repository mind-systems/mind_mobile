# Завершение сессии, режим ожидания и рестарт

## Завершение сессии

Когда BreathSessionEngine отрабатывает последнее упражнение и вызывает complete, происходит несколько вещей одновременно. Подписка на тики отменяется, поэтому дальнейшие сигналы от TickService не попадают в engine. Закрывается resetStream — поток, через который engine ранее оповещал визуальный слой о смене цикла или упражнения. Внутреннее состояние engine фиксируется со статусом complete, и это состояние выбрасывается в stateStream.

ViewModel подписан на stateStream и немедленно получает это финальное состояние. Через _onEngineState он транслирует его вовне как BreathSessionState с тем же статусом complete. Riverpod-нотификация разлетается по всем подписчикам — в первую очередь до BreathAnimationCoordinator и Screen.

Coordinator получает состояние в _onStateChanged. shouldBeActive вычисляется как false, потому что статус complete — не breath. Если до этого moment motionEngine был активен, условие shouldBeActive != motionEngine.isActive выполняется, и coordinator вызывает motionEngine.setActive(false). Тикер анимации останавливается. Визуальная точка замирает в том положении, где застала её последняя итерация тикера.

Screen, в свою очередь, перестраивает кнопку управления. Вместо pause/resume появляется кнопка restart.

## Режим ожидания

После завершения сессии весь модуль находится в состоянии покоя. BreathSessionEngine существует в памяти, но не производит никакой работы — его тиковая подписка отменена, оба стрима закрыты. ViewModel хранит ссылку на этот engine и ждёт команды. BreathAnimationCoordinator продолжает слушать ViewModel через свой stateListener, однако incoming состояния не изменяются — engine молчит. motionEngine не тикает. shapeShifter не морфит.

Единственная живая часть — это UI: Screen отображает итоговый вид сессии с кнопкой replay.

## Рестарт

Когда пользователь нажимает кнопку restart, Screen вызывает viewModel.restart(). ViewModel внутри вызывает _setupEngine с тем же BreathSessionDTO, который был загружен при первом запуске сессии. Старый engine уничтожается: отменяются его подписки, вызывается dispose. Создаётся новый экземпляр BreathSessionEngine с теми же данными. Новый engine начинает своё существование точно так же, как и при первом открытии экрана — в статусе pause, с первым упражнением, с нулевыми внутренними счётчиками.

ViewModel немедленно транслирует состояние нового engine наружу. Coordinator получает это состояние через _onStateChanged. Статус — pause, loadState — ready. shouldBeActive вычисляется как false. motionEngine уже остановлен после завершения предыдущей сессии, поэтому условие false != false не выполняется и лишних вызовов не происходит. _previousRemainingTicks обновляется до актуального значения нового engine через ветку else в секции "Структура фаз".

Кроме того, _resetStreamSubscribed сбрасывается в false, потому что старый resetStream закрыт, а новый engine выпустил свежий. При следующем вызове resume coordinator переподпишется на новый resetStream в начале _onStateChanged.

## Возврат к первоначальному состоянию

После рестарта весь модуль находится в том же состоянии, что и при первом открытии экрана после загрузки сессии. BreathSessionEngine — новый объект с нулевыми счётчиками. ViewModel транслирует состояние pause. motionEngine неактивен. shapeShifter отображает ту форму, в которой был инициализирован при открытии экрана. Coordinator не хранит никаких кэшей из предыдущей сессии, которые могли бы помешать нормальной работе.

Когда пользователь нажимает resume, цепочка событий разворачивается в точности как при первом старте: engine переходит в breath, ViewModel транслирует это состояние, coordinator видит переход motionEngine от false к true, инициализирует фазовую структуру через setPhaseInfo и setRemainingPhaseTicks, и запускает тикер через setActive(true).
