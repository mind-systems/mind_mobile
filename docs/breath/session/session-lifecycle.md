# Завершение сессии, режим ожидания и рестарт

## Завершение сессии

Когда BreathSessionStateMachine отрабатывает последнее упражнение и вызывает complete, происходит несколько вещей одновременно. Подписка на тики отменяется, поэтому дальнейшие сигналы от TickService не попадают в стейт-машину. Закрывается resetStream — поток, через который стейт-машина ранее оповещала визуальный слой о смене цикла или упражнения. Внутреннее состояние фиксируется со статусом complete, и это состояние выбрасывается в stateStream.

ViewModel подписан на stateStream и немедленно получает это финальное состояние. Через _onEngineState он транслирует его вовне как BreathSessionState с тем же статусом complete. Riverpod-нотификация разлетается по всем подписчикам — в первую очередь до BreathAnimationCoordinator и Screen.

Coordinator получает состояние в _onStateChanged. shouldBeActive вычисляется как false, потому что статус complete — не breath. Если до этого motionEngine был активен, условие shouldBeActive != motionEngine.isActive выполняется, и coordinator вызывает motionEngine.setActive(false). Тикер анимации останавливается. Визуальная точка замирает в том положении, где застала её последняя итерация тикера.

Screen, в свою очередь, перестраивает кнопку управления. Вместо pause/resume появляется кнопка restart.

## Режим ожидания

После завершения сессии весь модуль находится в состоянии покоя. BreathSessionStateMachine существует в памяти, но не производит никакой работы — её тиковая подписка отменена, оба стрима закрыты. ViewModel хранит ссылку на эту стейт-машину и ждёт команды. BreathAnimationCoordinator продолжает слушать ViewModel через свой stateListener, однако входящие состояния не изменяются — стейт-машина молчит. motionEngine не тикает. shapeShifter не морфит.

Единственная живая часть — это UI: Screen отображает итоговый вид сессии с кнопкой restart.

## Рестарт

Когда пользователь нажимает кнопку restart, Screen вызывает coordinator.reset() и orbCoordinator.reset(), а затем viewModel.restart(). Вызов coordinator.reset() деактивирует motionEngine и сбрасывает кэши внутреннего состояния координатора, возвращая его в то же положение, что и при первом открытии экрана. После этого viewModel.restart() вызывает _setupEngine с тем же BreathSessionDTO, который был загружен при первом запуске. Старая стейт-машина уничтожается: отменяются её подписки, вызывается dispose. Создаётся новый экземпляр BreathSessionStateMachine с теми же данными. Новый экземпляр начинает своё существование точно так же, как и при первом открытии экрана — в статусе pause, с первым упражнением, с нулевыми внутренними счётчиками.

ViewModel немедленно транслирует состояние новой стейт-машины наружу через Riverpod. Coordinator получает это состояние через _onStateChanged. Статус — pause, loadState — ready. shouldBeActive вычисляется как false. motionEngine уже деактивирован вызовом coordinator.reset(), поэтому условие false != false не выполняется и лишних вызовов не происходит.

Стабильность resetStream при рестарте обеспечивается proxy-паттерном внутри ViewModel. viewModel.resetStream — это постоянный стрим, который не пересоздаётся. При каждом вызове _setupEngine ViewModel переподписывает внутренний прокси на resetStream новой стейт-машины, и все внешние подписчики продолжают получать события без прерывания подписки.

## Возврат к первоначальному состоянию

После рестарта весь модуль находится в том же состоянии, что и при первом открытии экрана после загрузки сессии. BreathSessionStateMachine — новый объект с нулевыми счётчиками. ViewModel транслирует состояние pause. motionEngine неактивен. shapeShifter отображает ту форму, в которой был инициализирован при открытии экрана. Coordinator не хранит никаких кэшей из предыдущей сессии, которые могли бы помешать нормальной работе.

Когда пользователь нажимает resume, цепочка событий разворачивается в точности как при первом старте: стейт-машина переходит в breath, ViewModel транслирует это состояние, coordinator видит переход motionEngine от false к true, инициализирует фазовую структуру через setPhaseInfo и setRemainingPhaseTicks, и запускает тикер через setActive(true).
